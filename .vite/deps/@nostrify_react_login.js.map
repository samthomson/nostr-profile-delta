{
  "version": 3,
  "sources": ["../../node_modules/@jsr/nostrify__nostrify/BunkerURI.ts", "../../node_modules/@jsr/nostrify__nostrify/NBrowserSigner.ts", "../../node_modules/lru-cache/src/index.ts", "../../node_modules/@jsr/nostrify__nostrify/NSet.ts", "../../node_modules/@jsr/nostrify__nostrify/NCache.ts", "../../node_modules/zod/v3/index.js", "../../node_modules/zod/v3/external.js", "../../node_modules/zod/v3/helpers/util.js", "../../node_modules/zod/v3/ZodError.js", "../../node_modules/zod/v3/locales/en.js", "../../node_modules/zod/v3/errors.js", "../../node_modules/zod/v3/helpers/parseUtil.js", "../../node_modules/zod/v3/helpers/errorUtil.js", "../../node_modules/zod/v3/types.js", "../../node_modules/@jsr/nostrify__nostrify/NSchema.ts", "../../node_modules/@jsr/nostrify__nostrify/NConnectSigner.ts", "../../node_modules/@jsr/std__encoding/_validate_binary_like.ts", "../../node_modules/@jsr/std__encoding/hex.ts", "../../node_modules/@jsr/nostrify__nostrify/utils/CircularSet.ts", "../../node_modules/@jsr/nostrify__nostrify/utils/Machina.ts", "../../node_modules/@jsr/nostrify__nostrify/NPool.ts", "../../node_modules/websocket-ts/src/backoff/exponentialbackoff.ts", "../../node_modules/websocket-ts/src/queue/array_queue.ts", "../../node_modules/websocket-ts/src/websocket_event.ts", "../../node_modules/websocket-ts/src/websocket.ts", "../../node_modules/websocket-ts/src/websocket_builder.ts", "../../node_modules/@jsr/nostrify__nostrify/NRelay1.ts", "../../node_modules/@jsr/nostrify__nostrify/NSecSigner.ts", "../../node_modules/@nostrify/react/login/NLogin.ts", "../../node_modules/@nostrify/react/login/NostrLoginProvider.ts", "../../node_modules/@nostrify/react/login/NostrLoginContext.ts", "../../node_modules/@nostrify/react/login/useNostrLoginReducer.ts", "../../node_modules/@nostrify/react/login/nostrLoginReducer.ts", "../../node_modules/@nostrify/react/login/NUser.ts", "../../node_modules/@nostrify/react/login/useNostrLogin.ts"],
  "sourcesContent": ["/** Construct a [NIP-46](https://github.com/nostr-protocol/nips/blob/master/46.md) bunker URI. */\nexport class BunkerURI {\n  /** Remote signer pubkey. */\n  pubkey: string;\n  /** Relay URLs on which the client is listening for responses from the remote-signer. */\n  relays: string[];\n  /** A short random string that the remote-signer should return as the `result` field of its response. */\n  secret?: string;\n\n  constructor(uri: string) {\n    const url = new URL(uri);\n    const params = new URLSearchParams(url.search);\n\n    // https://github.com/denoland/deno/issues/26440\n    const pubkey = url.hostname || url.pathname.slice(2);\n    const relays = params.getAll('relay');\n    const secret = params.get('secret') ?? undefined;\n\n    if (!pubkey) {\n      throw new Error('Invalid bunker URI');\n    }\n\n    this.pubkey = pubkey;\n    this.relays = relays;\n    this.secret = secret;\n  }\n\n  /** Convert into a `bunker://` URI string. */\n  get href(): string {\n    return this.toString();\n  }\n\n  /** Convert into a `bunker://` URI string. */\n  toString(): string {\n    return BunkerURI.toString(this);\n  }\n\n  /** Convert a bunker data object into a `BunkerURI` instance. */\n  static fromJSON(data: { pubkey: string; relays: string[]; secret?: string }): BunkerURI {\n    const uri = BunkerURI.toString(data);\n    return new BunkerURI(uri);\n  }\n\n  /** Convert a bunker data object into a bunker URI string. */\n  private static toString(data: { pubkey: string; relays: string[]; secret?: string }): string {\n    const search = new URLSearchParams();\n\n    for (const relay of data.relays) {\n      search.append('relay', relay);\n    }\n\n    if (data.secret) {\n      search.set('secret', data.secret);\n    }\n\n    return `bunker://${data.pubkey}?${search.toString()}`;\n  }\n}\n", "import type { NostrEvent, NostrSigner } from 'jsr:@nostrify/types@^0.36.0';\n\n/**\n * NIP-07-compatible signer that proxies to browser extension, normalizing behavior across different implementations.\n *\n * This signer delegates all operations to the browser's `window.nostr` object,\n * which is typically provided by browser extensions like Alby, nos2x, etc.\n *\n * Usage:\n *\n * ```ts\n * const signer = new NBrowserSigner();\n * const pubkey = await signer.getPublicKey();\n * const event = await signer.signEvent({ kind: 1, content: 'Hello, world!', tags: [], created_at: 0 });\n * ```\n */\nexport class NBrowserSigner implements NostrSigner {\n  private get nostr(): NostrSigner {\n    const nostr = (globalThis as { nostr?: NostrSigner }).nostr;\n    if (!nostr) {\n      throw new Error('Browser extension not available');\n    }\n    return nostr;\n  }\n\n  async getPublicKey(): Promise<string> {\n    const pubkey = await this.nostr.getPublicKey();\n    if (typeof pubkey !== 'string') {\n      throw new Error(`Nostr public key retrieval failed: expected string, got ${JSON.stringify(pubkey)}`);\n    }\n    return pubkey;\n  }\n\n  async signEvent(event: Omit<NostrEvent, 'id' | 'pubkey' | 'sig'>): Promise<NostrEvent> {\n    const signed = await this.nostr.signEvent(event);\n    if (typeof signed !== 'object' || !signed.id || !signed.pubkey || !signed.sig) {\n      throw new Error(\n        `Nostr event signing failed: expected object with id, pubkey, and sig, got ${JSON.stringify(signed)}`,\n      );\n    }\n    return signed;\n  }\n\n  async getRelays(): Promise<Record<string, { read: boolean; write: boolean }>> {\n    if (!this.nostr.getRelays) {\n      return {};\n    }\n    const relays = await this.nostr.getRelays();\n    if (typeof relays !== 'object' || relays === null) {\n      throw new Error(`Nostr getRelays failed: expected object, got ${JSON.stringify(relays)}`);\n    }\n    return this.nostr.getRelays();\n  }\n\n  get nip04(): NostrSigner['nip04'] {\n    const nostr = this.nostr;\n    if (!nostr.nip04) {\n      return undefined;\n    }\n    return {\n      encrypt: async (pubkey: string, plaintext: string): Promise<string> => {\n        const encrypted = await nostr.nip04!.encrypt(pubkey, plaintext);\n        if (typeof encrypted !== 'string') {\n          throw new Error(`NIP-04 encryption failed: expected string result, got ${JSON.stringify(encrypted)}`);\n        }\n        return encrypted;\n      },\n      decrypt: async (pubkey: string, ciphertext: string): Promise<string> => {\n        const decrypted = await nostr.nip04!.decrypt(pubkey, ciphertext);\n        if (typeof decrypted !== 'string') {\n          throw new Error(`NIP-04 decryption failed: expected string result, got ${JSON.stringify(decrypted)}`);\n        }\n        return decrypted;\n      },\n    };\n  }\n\n  get nip44(): NostrSigner['nip44'] {\n    const nostr = this.nostr;\n    if (!nostr.nip44) {\n      return undefined;\n    }\n    return {\n      encrypt: async (pubkey: string, plaintext: string): Promise<string> => {\n        const encrypted = await nostr.nip44!.encrypt(pubkey, plaintext);\n        if (typeof encrypted !== 'string') {\n          throw new Error(`NIP-44 encryption failed: expected string result, got ${JSON.stringify(encrypted)}`);\n        }\n        return encrypted;\n      },\n      decrypt: async (pubkey: string, ciphertext: string): Promise<string> => {\n        const decrypted = await nostr.nip44!.decrypt(pubkey, ciphertext);\n        if (typeof decrypted !== 'string') {\n          throw new Error(`NIP-44 decryption failed: expected string result, got ${JSON.stringify(decrypted)}`);\n        }\n        return decrypted;\n      },\n    };\n  }\n}\n", "/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "import { NostrEvent } from '@jsr/nostrify__types';\n\n/**\n * Nostr event implementation of the `Set` interface.\n *\n * NSet is an implementation of the theory that a Nostr Storage is actually just a Set.\n * Events are Nostr's only data type, and they are immutable, making the Set interface ideal.\n *\n * ```ts\n * const events = new NSet();\n *\n * // Events can be added like a regular `Set`:\n * events.add(event1);\n * events.add(event2);\n *\n * // Can be iterated:\n * for (const event of events) {\n *   if (matchFilters(filters, event)) {\n *     console.log(event);\n *   }\n * }\n * ```\n *\n * `NSet` will handle kind `5` deletions, removing events from the set.\n * Replaceable (and parameterized) events will keep only the newest version.\n * However, verification of `id` and `sig` is NOT performed.\n *\n * Any `Map` instance can be passed into `new NSet()`, making it compatible with\n * [lru-cache](https://www.npmjs.com/package/lru-cache), among others.\n */\nclass NSet {\n  protected cache: Map<string, NostrEvent>;\n\n  constructor(map?: Map<string, NostrEvent>) {\n    this.cache = map ?? new Map();\n  }\n\n  get size(): number {\n    return this.cache.size;\n  }\n\n  add(event: NostrEvent): this {\n    this.#processDeletions(event);\n\n    for (const e of this) {\n      if (NSet.deletes(e, event) || NSet.replaces(e, event)) {\n        return this;\n      } else if (NSet.replaces(event, e)) {\n        this.delete(e);\n      }\n    }\n\n    this.cache.set(event.id, event);\n    return this;\n  }\n\n  #processDeletions(event: NostrEvent): void {\n    if (event.kind === 5) {\n      for (const tag of event.tags) {\n        if (tag[0] === 'e') {\n          const e = this.cache.get(tag[1]);\n          if (e && e.pubkey === event.pubkey) {\n            this.delete(e);\n          }\n        }\n      }\n    }\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  delete(event: NostrEvent): boolean {\n    return this.cache.delete(event.id);\n  }\n\n  forEach(callbackfn: (event: NostrEvent, key: NostrEvent, set: typeof this) => void, thisArg?: any): void {\n    return this.cache.forEach((event, _id) => callbackfn(event, event, this), thisArg);\n  }\n\n  has(event: NostrEvent): boolean {\n    return this.cache.has(event.id);\n  }\n\n  *entries(): IterableIterator<[NostrEvent, NostrEvent]> {\n    for (const event of this.values()) {\n      yield [event, event];\n    }\n  }\n\n  keys(): IterableIterator<NostrEvent> {\n    return this.values();\n  }\n\n  *values(): IterableIterator<NostrEvent> {\n    for (const event of NSet.sortEvents([...this.cache.values()])) {\n      yield event;\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<NostrEvent> {\n    return this.values();\n  }\n\n  [Symbol.toStringTag]: string = 'NSet';\n\n  /** Event kind is **replaceable**, which means that, for each combination of `pubkey` and `kind`, only the latest event is expected to (SHOULD) be stored by relays, older versions are expected to be discarded. */\n  protected static isReplaceable(kind: number): boolean {\n    return [0, 3].includes(kind) || (10000 <= kind && kind < 20000);\n  }\n\n  /** Event kind is **parameterized replaceable**, which means that, for each combination of `pubkey`, `kind` and the `d` tag, only the latest event is expected to be stored by relays, older versions are expected to be discarded. */\n  protected static isAddressable(kind: number): boolean {\n    return 30000 <= kind && kind < 40000;\n  }\n\n  /**\n   * Returns true if `event` replaces `target`.\n   *\n   * Both events must be replaceable, belong to the same kind and pubkey (and `d` tag, for parameterized events), and the `event` must be newer than the `target`.\n   */\n  protected static replaces(event: NostrEvent, target: NostrEvent): boolean {\n    const { kind, pubkey } = event;\n\n    if (NSet.isReplaceable(kind)) {\n      return kind === target.kind && pubkey === target.pubkey && NSet.sortEvents([event, target])[0] === event;\n    }\n\n    if (NSet.isAddressable(kind)) {\n      const d1 = event.tags.find(([name]) => name === 'd')?.[1] || '';\n      const d2 = target.tags.find(([name]) => name === 'd')?.[1] || '';\n\n      return kind === target.kind &&\n        pubkey === target.pubkey &&\n        NSet.sortEvents([event, target])[0] === event &&\n        d1 === d2;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the `event` deletes`target`.\n   *\n   * `event` must be a kind `5` event, and both events must share the same `pubkey`.\n   */\n  protected static deletes(event: NostrEvent, target: NostrEvent): boolean {\n    const { kind, pubkey, tags } = event;\n    if (kind === 5 && pubkey === target.pubkey) {\n      for (const [name, value] of tags) {\n        if (name === 'e' && value === target.id) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sort events in reverse-chronological order by the `created_at` timestamp,\n   * and then by the event `id` (lexicographically) in case of ties.\n   * This mutates the array.\n   */\n  protected static sortEvents(events: NostrEvent[]): NostrEvent[] {\n    return events.sort((a: NostrEvent, b: NostrEvent): number => {\n      if (a.created_at !== b.created_at) {\n        return b.created_at - a.created_at;\n      }\n      return a.id.localeCompare(b.id);\n    });\n  }\n\n  union<U>(_other: Set<U>): Set<NostrEvent | U> {\n    throw new Error('Method not implemented.');\n  }\n\n  intersection<U>(_other: Set<U>): Set<NostrEvent & U> {\n    throw new Error('Method not implemented.');\n  }\n\n  difference<U>(_other: Set<U>): Set<NostrEvent> {\n    throw new Error('Method not implemented.');\n  }\n\n  symmetricDifference<U>(_other: Set<U>): Set<NostrEvent | U> {\n    throw new Error('Method not implemented.');\n  }\n\n  isSubsetOf(_other: Set<unknown>): boolean {\n    throw new Error('Method not implemented.');\n  }\n\n  isSupersetOf(_other: Set<unknown>): boolean {\n    throw new Error('Method not implemented.');\n  }\n\n  isDisjointFrom(_other: Set<unknown>): boolean {\n    throw new Error('Method not implemented.');\n  }\n}\n\nexport { NSet };\n", "// deno-lint-ignore-file require-await\n\nimport { NostrEvent, NostrFilter, NostrRelayCOUNT, NStore } from '@jsr/nostrify__types';\nimport { LRUCache } from 'lru-cache';\nimport { matchFilters } from 'nostr-tools';\n\nimport { NSet } from './NSet.js';\n\n/**\n * Nostr LRU cache based on [`npm:lru-cache`](https://www.npmjs.com/package/lru-cache).\n * It implements both `NStore` and `NSet` interfaces.\n *\n * ```ts\n * // Accepts the options of `npm:lru-cache`:\n * const cache = new NCache({ max: 1000 });\n *\n * // Events can be added like a regular `Set`:\n * cache.add(event1);\n * cache.add(event2);\n *\n * // Can be queried like `NStore`:\n * const events = await cache.query([{ kinds: [1] }]);\n *\n * // Can be iterated like `NSet`:\n * for (const event of cache) {\n *  console.log(event);\n * }\n * ```\n */\nclass NCache extends NSet implements NStore {\n  constructor(...args: ConstructorParameters<typeof LRUCache<string, NostrEvent>>) {\n    super(new LRUCache<string, NostrEvent>(...args) as Map<string, NostrEvent>);\n  }\n\n  async event(event: NostrEvent): Promise<void> {\n    this.add(event);\n  }\n\n  async query(filters: NostrFilter[]): Promise<NostrEvent[]> {\n    const events: NostrEvent[] = [];\n\n    for (const event of this) {\n      if (matchFilters(filters, event)) {\n        this.cache.get(event.id);\n        events.push(event);\n      }\n    }\n\n    return events;\n  }\n\n  async remove(filters: NostrFilter[]): Promise<void> {\n    for (const event of this) {\n      if (matchFilters(filters, event)) {\n        this.delete(event);\n      }\n    }\n  }\n\n  async count(filters: NostrFilter[]): Promise<NostrRelayCOUNT[2]> {\n    const events = await this.query(filters);\n    return {\n      count: events.length,\n      approximate: false,\n    };\n  }\n\n  override [Symbol.toStringTag] = 'NCache';\n}\n\nexport { NCache };\n", "import * as z from \"./external.js\";\nexport * from \"./external.js\";\nexport { z };\nexport default z;\n", "export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n", "export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n", "import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n", "import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n", "import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n", "import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n", "export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n", "import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n", "import { z } from 'zod';\n\nimport {\n  NostrClientAUTH,\n  NostrClientCLOSE,\n  NostrClientCOUNT,\n  NostrClientEVENT,\n  NostrClientMsg,\n  NostrClientREQ,\n  NostrConnectRequest,\n  NostrConnectResponse,\n  NostrEvent,\n  NostrFilter,\n  NostrMetadata,\n  NostrRelayAUTH,\n  NostrRelayCLOSED,\n  NostrRelayCOUNT,\n  NostrRelayEOSE,\n  NostrRelayEVENT,\n  NostrRelayMsg,\n  NostrRelayNOTICE,\n  NostrRelayOK,\n} from '@jsr/nostrify__types';\n\n/**\n * A suite of [zod](https://github.com/colinhacks/zod) schemas for Nostr.\n *\n * ```ts\n * import { NSchema as n } from '@nostrify/nostrify';\n *\n * const event: NostrEvent = n.event().parse(eventData);\n * const metadata: NostrMetadata = n.json().pipe(n.metadata()).parse(event.content);\n * const msg: NostrRelayMsg = n.relayMsg().parse(e.data);\n * const nsec: `nsec1${string}` = n.bech32('nsec').parse(token);\n * ```\n */\nclass NSchema {\n  /** Schema to validate Nostr hex IDs such as event IDs and pubkeys. */\n  static id(): z.ZodString {\n    return z.string().regex(/^[0-9a-f]{64}$/);\n  }\n\n  /** Nostr event schema. */\n  static event(): z.ZodType<NostrEvent> {\n    return z.object({\n      id: NSchema.id(),\n      kind: z.number().int().nonnegative(),\n      pubkey: NSchema.id(),\n      tags: z.string().array().array(),\n      content: z.string(),\n      created_at: z.number().int().nonnegative(),\n      sig: z.string(),\n    });\n  }\n\n  /** Nostr filter schema. */\n  static filter(): z.ZodType<NostrFilter> {\n    return z.object({\n      kinds: z.number().int().nonnegative().array().optional(),\n      ids: NSchema.id().array().optional(),\n      authors: NSchema.id().array().optional(),\n      since: z.number().int().nonnegative().optional(),\n      until: z.number().int().nonnegative().optional(),\n      limit: z.number().int().nonnegative().optional(),\n      search: z.string().optional(),\n    })\n      .passthrough()\n      .transform((value) => {\n        const keys = ['kinds', 'ids', 'authors', 'since', 'until', 'limit', 'search'];\n        return Object.entries(value).reduce((acc, [key, val]) => {\n          if (keys.includes(key) || key.startsWith('#')) {\n            acc[key] = val;\n          }\n          return acc;\n        }, {} as Record<string, unknown>) as NostrFilter;\n      }) as z.ZodType<NostrFilter>;\n  }\n\n  /**\n   * Bech32 string.\n   * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32\n   */\n  static bech32<P extends string>(prefix?: P): z.ZodType<`${P}1${string}`> {\n    return z\n      .string()\n      .regex(/^[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}$/)\n      .refine((value) => prefix ? value.startsWith(`${prefix}1`) : true) as z.ZodType<`${P}1${string}`>;\n  }\n\n  /** WebSocket URL starting with `ws://` or `wss://`. */\n  static relayUrl(): z.ZodType<`ws://${string}` | `wss://${string}`> {\n    return z\n      .string()\n      .url()\n      .regex(/^wss?:\\/\\//) as z.ZodType<`ws://${string}` | `wss://${string}`>;\n  }\n\n  /** NIP-01 `EVENT` message from client to relay. */\n  static clientEVENT(): z.ZodType<NostrClientEVENT> {\n    return z.tuple([z.literal('EVENT'), NSchema.event()]);\n  }\n\n  /** NIP-01 `REQ` message from client to relay. */\n  static clientREQ(): z.ZodType<NostrClientREQ> {\n    return z.tuple([z.literal('REQ'), z.string()]).rest(NSchema.filter());\n  }\n\n  /** NIP-45 `COUNT` message from client to relay. */\n  static clientCOUNT(): z.ZodType<NostrClientCOUNT> {\n    return z.tuple([z.literal('COUNT'), z.string()]).rest(NSchema.filter());\n  }\n\n  /** NIP-01 `CLOSE` message from client to relay. */\n  static clientCLOSE(): z.ZodType<NostrClientCLOSE> {\n    return z.tuple([z.literal('CLOSE'), z.string()]);\n  }\n\n  /** NIP-42 `AUTH` message from client to relay. */\n  static clientAUTH(): z.ZodType<NostrClientAUTH> {\n    return z.tuple([z.literal('AUTH'), NSchema.event()]);\n  }\n\n  /** NIP-01 message from client to relay. */\n  static clientMsg(): z.ZodType<NostrClientMsg> {\n    return z.union([\n      NSchema.clientEVENT(),\n      NSchema.clientREQ(),\n      NSchema.clientCOUNT(),\n      NSchema.clientCLOSE(),\n      NSchema.clientAUTH(),\n    ]);\n  }\n\n  /** NIP-01 `EVENT` message from relay to client. */\n  static relayEVENT(): z.ZodType<NostrRelayEVENT> {\n    return z.tuple([z.literal('EVENT'), z.string(), NSchema.event()]);\n  }\n\n  /** NIP-01 `OK` message from relay to client. */\n  static relayOK(): z.ZodType<NostrRelayOK> {\n    return z.tuple([z.literal('OK'), NSchema.id(), z.boolean(), z.string()]);\n  }\n\n  /** NIP-01 `EOSE` message from relay to client. */\n  static relayEOSE(): z.ZodType<NostrRelayEOSE> {\n    return z.tuple([z.literal('EOSE'), z.string()]);\n  }\n\n  /** NIP-01 `NOTICE` message from relay to client. */\n  static relayNOTICE(): z.ZodType<NostrRelayNOTICE> {\n    return z.tuple([z.literal('NOTICE'), z.string()]);\n  }\n\n  /** NIP-01 `CLOSED` message from relay to client. */\n  static relayCLOSED(): z.ZodType<NostrRelayCLOSED> {\n    return z.tuple([z.literal('CLOSED'), z.string(), z.string()]);\n  }\n\n  /** NIP-42 `AUTH` message from relay to client. */\n  static relayAUTH(): z.ZodType<NostrRelayAUTH> {\n    return z.tuple([z.literal('AUTH'), z.string()]);\n  }\n\n  /** NIP-45 `COUNT` message from relay to client. */\n  static relayCOUNT(): z.ZodType<NostrRelayCOUNT> {\n    return z.tuple([\n      z.literal('COUNT'),\n      z.string(),\n      z.object({\n        count: z.number().int().nonnegative(),\n        approximate: z.boolean().optional(),\n      }),\n    ]);\n  }\n\n  /** NIP-01 message from relay to client. */\n  static relayMsg(): z.ZodType<NostrRelayMsg> {\n    return z.union([\n      NSchema.relayEVENT(),\n      NSchema.relayOK(),\n      NSchema.relayEOSE(),\n      NSchema.relayNOTICE(),\n      NSchema.relayCLOSED(),\n      NSchema.relayAUTH(),\n      NSchema.relayCOUNT(),\n    ]);\n  }\n\n  /** Kind 0 content schema. */\n  static metadata(): z.ZodType<NostrMetadata> {\n    return z.object({\n      about: z.string().optional().catch(undefined),\n      banner: z.string().url().optional().catch(undefined),\n      bot: z.boolean().optional().catch(undefined),\n      display_name: z.string().optional().catch(undefined),\n      lud06: NSchema.bech32('lnurl').optional().catch(undefined),\n      lud16: z.string().email().optional().catch(undefined),\n      name: z.string().optional().catch(undefined),\n      nip05: z.string().email().optional().catch(undefined),\n      picture: z.string().url().optional().catch(undefined),\n      website: z.string().url().optional().catch(undefined),\n    }).passthrough() as z.ZodType<NostrMetadata>;\n  }\n\n  /** NIP-46 request content schema. */\n  static connectRequest(): z.ZodType<NostrConnectRequest> {\n    return z.object({\n      id: z.string(),\n      method: z.string(),\n      params: z.string().array(),\n    });\n  }\n\n  /** NIP-46 response content schema. */\n  static connectResponse(): z.ZodType<NostrConnectResponse> {\n    return z.object({\n      id: z.string(),\n      result: z.string(),\n      error: z.string().optional(),\n    });\n  }\n\n  /**\n   * Helper schema to parse a JSON string. It should then be piped into another schema. For example:\n   *\n   * ```ts\n   * const event = NSchema.json().pipe(NSchema.event()).parse(data);\n   * ```\n   */\n  static json(): z.ZodType<unknown> {\n    return z.string().transform((value, ctx) => {\n      try {\n        return JSON.parse(value) as unknown;\n      } catch (_e) {\n        ctx.addIssue({ code: z.ZodIssueCode.custom, message: 'Invalid JSON' });\n        return z.NEVER;\n      }\n    });\n  }\n}\n\nexport { NSchema, z };\n", "// deno-lint-ignore-file require-await\n\nimport { z } from 'zod';\n\nimport { NostrConnectRequest, NostrConnectResponse, NostrEvent, NostrSigner, NRelay } from '@jsr/nostrify__types';\n\nimport { NSchema as n } from './NSchema.js';\n\n/** Options for `NConnectSigner`. */\nexport interface NConnectSignerOpts {\n  /** Relay to facilitate connection. */\n  relay: NRelay;\n  /** Remote pubkey to sign as. */\n  pubkey: string;\n  /** Local signer to sign the request events. */\n  signer: NostrSigner;\n  /** Timeout for requests. */\n  timeout?: number;\n  /** Encryption to use when encrypting local messages. Decryption is automatic. */\n  encryption?: 'nip04' | 'nip44';\n}\n\n/** [NIP-46](https://github.com/nostr-protocol/nips/blob/master/46.md) remote signer through a relay. */\nexport class NConnectSigner implements NostrSigner {\n  private relay: NRelay;\n  private pubkey: string;\n  private signer: NostrSigner;\n  private timeout?: number;\n  private encryption: 'nip04' | 'nip44';\n\n  constructor({ relay, pubkey, signer, timeout, encryption = 'nip44' }: NConnectSignerOpts) {\n    this.relay = relay;\n    this.pubkey = pubkey;\n    this.signer = signer;\n    this.timeout = timeout;\n    this.encryption = encryption;\n  }\n\n  async getPublicKey(): Promise<string> {\n    return this.cmd('get_public_key', []);\n  }\n\n  async signEvent(event: Omit<NostrEvent, 'id' | 'pubkey' | 'sig'>): Promise<NostrEvent> {\n    const result = await this.cmd('sign_event', [JSON.stringify(event)]);\n    return n.json().pipe(n.event()).parse(result);\n  }\n\n  async getRelays(): Promise<Record<string, { read: boolean; write: boolean }>> {\n    const result = await this.cmd('get_relays', []);\n\n    return n\n      .json()\n      .pipe(z.record(z.string(), z.object({ read: z.boolean(), write: z.boolean() })))\n      .parse(result);\n  }\n\n  readonly nip04 = {\n    encrypt: async (pubkey: string, plaintext: string): Promise<string> => {\n      return this.cmd('nip04_encrypt', [pubkey, plaintext]);\n    },\n\n    decrypt: async (pubkey: string, ciphertext: string): Promise<string> => {\n      return this.cmd('nip04_decrypt', [pubkey, ciphertext]);\n    },\n  };\n\n  readonly nip44 = {\n    encrypt: async (pubkey: string, plaintext: string): Promise<string> => {\n      return this.cmd('nip44_encrypt', [pubkey, plaintext]);\n    },\n\n    decrypt: async (pubkey: string, ciphertext: string): Promise<string> => {\n      return this.cmd('nip44_decrypt', [pubkey, ciphertext]);\n    },\n  };\n\n  /** Send a `connect` command to the relay. It should respond with `ack`. */\n  async connect(secret?: string): Promise<string> {\n    const params: string[] = [this.pubkey];\n\n    if (secret) {\n      params.push(secret);\n    }\n\n    return this.cmd('connect', params);\n  }\n\n  /** Send a `ping` command to the signer. It should respond with `pong`. */\n  async ping(): Promise<string> {\n    return this.cmd('ping', []);\n  }\n\n  /** High-level RPC method. Returns the string result, or throws on error. */\n  private async cmd(method: string, params: string[]): Promise<string> {\n    const signal = typeof this.timeout === 'number' ? AbortSignal.timeout(this.timeout) : undefined;\n\n    const { result, error } = await this.send(\n      { id: crypto.randomUUID(), method, params },\n      { signal },\n    );\n\n    if (error) {\n      throw new Error(error);\n    }\n\n    return result;\n  }\n\n  /** Low-level send method. Deals directly with connect request/response. */\n  private async send(request: NostrConnectRequest, opts: { signal?: AbortSignal } = {}): Promise<NostrConnectResponse> {\n    const { signal } = opts;\n\n    const event = await this.signer.signEvent({\n      kind: 24133,\n      content: await this.encrypt(this.pubkey, JSON.stringify(request)),\n      created_at: Math.floor(Date.now() / 1000),\n      tags: [['p', this.pubkey]],\n    });\n\n    const local = await this.signer.getPublicKey();\n\n    const req = this.relay.req(\n      [{ kinds: [24133], authors: [this.pubkey], '#p': [local] }],\n      { signal },\n    );\n\n    // Ensure the REQ is opened before sending the EVENT\n    const promise = new Promise<NostrConnectResponse>((resolve, reject) => {\n      (async () => {\n        try {\n          for await (const msg of req) {\n            if (msg[0] === 'CLOSED') throw new Error('Subscription closed');\n            if (msg[0] === 'EVENT') {\n              const event = msg[2];\n              const decrypted = await this.decrypt(this.pubkey, event.content);\n              const response = n.json().pipe(n.connectResponse()).parse(decrypted);\n              if (response.id === request.id) {\n                resolve(response);\n                return;\n              }\n            }\n          }\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n\n    await this.relay.event(event, { signal });\n    return promise;\n  }\n\n  /** Local encrypt depending on settings. */\n  private async encrypt(pubkey: string, plaintext: string): Promise<string> {\n    switch (this.encryption) {\n      case 'nip04':\n        return this.signer.nip04!.encrypt(pubkey, plaintext);\n      case 'nip44':\n        return this.signer.nip44!.encrypt(pubkey, plaintext);\n    }\n  }\n\n  /** Local decrypt depending on settings. */\n  private async decrypt(pubkey: string, ciphertext: string): Promise<string> {\n    switch (this.encryption) {\n      case 'nip04':\n        return this.signer.nip04!.decrypt(pubkey, ciphertext);\n      case 'nip44':\n        return this.signer.nip44!.decrypt(pubkey, ciphertext);\n    }\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\nconst encoder = new TextEncoder();\n\nfunction getTypeName(value: unknown): string {\n  const type = typeof value;\n  if (type !== \"object\") {\n    return type;\n  } else if (value === null) {\n    return \"null\";\n  } else {\n    return value?.constructor?.name ?? \"object\";\n  }\n}\n\nexport function validateBinaryLike(source: unknown): Uint8Array {\n  if (typeof source === \"string\") {\n    return encoder.encode(source);\n  } else if (source instanceof Uint8Array) {\n    return source;\n  } else if (source instanceof ArrayBuffer) {\n    return new Uint8Array(source);\n  }\n  throw new TypeError(\n    `The input must be a Uint8Array, a string, or an ArrayBuffer. Received a value of the type ${\n      getTypeName(source)\n    }.`,\n  );\n}\n", "// Copyright 2009 The Go Authors. All rights reserved.\n// https://github.com/golang/go/blob/master/LICENSE\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Port of the Go\n * {@link https://github.com/golang/go/blob/go1.12.5/src/encoding/hex/hex.go | encoding/hex}\n * library.\n *\n * This module is browser compatible.\n *\n * ```ts\n * import {\n *   decodeHex,\n *   encodeHex,\n * } from \"@std/encoding/hex\";\n * import { assertEquals } from \"@std/assert/assert-equals\";\n *\n * assertEquals(encodeHex(\"abc\"), \"616263\");\n *\n * assertEquals(\n *   decodeHex(\"616263\"),\n *   new TextEncoder().encode(\"abc\"),\n * );\n * ```\n *\n * @module\n */\n\nimport { validateBinaryLike } from \"./_validate_binary_like.js\";\n\nconst hexTable = new TextEncoder().encode(\"0123456789abcdef\");\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\nfunction errInvalidByte(byte: number) {\n  return new TypeError(`Invalid byte '${String.fromCharCode(byte)}'`);\n}\n\nfunction errLength() {\n  return new RangeError(\"Odd length hex string\");\n}\n\n/** Converts a hex character into its value. */\nfunction fromHexChar(byte: number): number {\n  // '0' <= byte && byte <= '9'\n  if (48 <= byte && byte <= 57) return byte - 48;\n  // 'a' <= byte && byte <= 'f'\n  if (97 <= byte && byte <= 102) return byte - 97 + 10;\n  // 'A' <= byte && byte <= 'F'\n  if (65 <= byte && byte <= 70) return byte - 65 + 10;\n\n  throw errInvalidByte(byte);\n}\n\n/**\n * Converts data into a hex-encoded string.\n *\n * @param src The data to encode.\n *\n * @returns The hex-encoded string.\n *\n * @example Usage\n * ```ts\n * import { encodeHex } from \"@std/encoding/hex\";\n * import { assertEquals } from \"@std/assert/assert-equals\";\n *\n * assertEquals(encodeHex(\"abc\"), \"616263\");\n * ```\n */\nexport function encodeHex(src: string | Uint8Array | ArrayBuffer): string {\n  const u8 = validateBinaryLike(src);\n\n  const dst = new Uint8Array(u8.length * 2);\n  for (let i = 0; i < dst.length; i++) {\n    const v = u8[i]!;\n    dst[i * 2] = hexTable[v >> 4]!;\n    dst[i * 2 + 1] = hexTable[v & 0x0f]!;\n  }\n  return textDecoder.decode(dst);\n}\n\n/**\n * Decodes the given hex-encoded string. If the input is malformed, an error is\n * thrown.\n *\n * @param src The hex-encoded string to decode.\n *\n * @returns The decoded data.\n *\n * @example Usage\n * ```ts\n * import { decodeHex } from \"@std/encoding/hex\";\n * import { assertEquals } from \"@std/assert/assert-equals\";\n *\n * assertEquals(\n *   decodeHex(\"616263\"),\n *   new TextEncoder().encode(\"abc\"),\n * );\n * ```\n */\nexport function decodeHex(src: string): Uint8Array {\n  const u8 = textEncoder.encode(src);\n  const dst = new Uint8Array(u8.length / 2);\n  for (let i = 0; i < dst.length; i++) {\n    const a = fromHexChar(u8[i * 2]!);\n    const b = fromHexChar(u8[i * 2 + 1]!);\n    dst[i] = (a << 4) | b;\n  }\n\n  if (u8.length % 2 === 1) {\n    // Check for invalid char before reporting bad length,\n    // since the invalid char (if present) is an earlier problem.\n    fromHexChar(u8[dst.length * 2]!);\n    throw errLength();\n  }\n\n  return dst;\n}\n", "/**\n * Like a Circular Buffer, but the values are deduplicated.\n * Shares the properties of both a Circular Buffer and a Set.\n */\nexport class CircularSet<T> {\n  private set: Set<T>;\n\n  constructor(private capacity: number) {\n    this.set = new Set();\n  }\n\n  add(item: T): void {\n    if (this.set.has(item)) {\n      return;\n    }\n\n    if (this.set.size >= this.capacity) {\n      const oldest = this.set.values().next().value;\n      if (oldest) {\n        this.set.delete(oldest);\n      }\n    }\n\n    this.set.add(item);\n  }\n\n  has(item: T): boolean {\n    return this.set.has(item);\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    return this.set.values();\n  }\n}\n", "/**\n * Infinite async generator. Iterates messages pushed to it until closed.\n * Only one consumer is expected to use a Machina instance at a time.\n *\n * @example\n * ```ts\n * // Create the Machina instance\n * const machina = new Machina<string>();\n *\n * // Async generator loop\n * async function getMessages() {\n *   for await (const msg of machina.stream()) {\n *     console.log(msg);\n *   }\n * }\n *\n * // Start the generator\n * getMessages();\n *\n * // Push messages to it\n * machina.push('hello!');\n * machina.push('whats up?');\n * machina.push('greetings');\n * ```\n */\nexport class Machina<T> implements AsyncIterable<T> {\n  #queue: T[] = [];\n  #resolve: (() => void) | undefined;\n  #aborted = false;\n\n  constructor(signal?: AbortSignal) {\n    if (signal?.aborted) {\n      this.abort();\n    } else {\n      signal?.addEventListener('abort', () => this.abort(), { once: true });\n    }\n  }\n\n  /** Get messages as an AsyncIterable. */\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    while (!this.#aborted) {\n      if (this.#queue.length) {\n        yield this.#queue.shift() as T;\n        continue;\n      }\n\n      await new Promise<void>((_resolve) => {\n        this.#resolve = _resolve;\n      });\n    }\n\n    throw new DOMException('The signal has been aborted', 'AbortError');\n  }\n\n  /** Push a message into the Machina instance, making it available to the consumer of `stream()`. */\n  push(data: T): void {\n    this.#queue.push(data);\n    this.#resolve?.();\n  }\n\n  /** Stops streaming and throws an error to the consumer. */\n  private abort(): void {\n    this.#aborted = true;\n    this.#resolve?.();\n  }\n}\n", "import { NostrEvent, NostrFilter, NostrRelayCLOSED, NostrRelayEOSE, NostrRelayEVENT, NRelay } from '@jsr/nostrify__types';\nimport { getFilterLimit } from 'nostr-tools';\n\nimport { CircularSet } from './utils/CircularSet.js';\nimport { Machina } from './utils/Machina.js';\nimport { NSet } from './NSet.js';\n\nexport interface NPoolOpts<T extends NRelay> {\n  /** Creates an `NRelay` instance for the given URL. */\n  open(url: string): T;\n  /** Determines the relays to use for making `REQ`s to the given filters. To support the Outbox model, it should analyze the `authors` field of the filters. */\n  reqRouter(filters: NostrFilter[]): ReadonlyMap<string, NostrFilter[]> | Promise<ReadonlyMap<string, NostrFilter[]>>;\n  /** Determines the relays to use for publishing the given event. To support the Outbox model, it should analyze the `pubkey` field of the event. */\n  eventRouter(event: NostrEvent): string[] | Promise<string[]>;\n}\n\n/**\n * The `NPool` class is a `NRelay` implementation for connecting to multiple relays.\n *\n * ```ts\n * const pool = new NPool({\n *   open: (url) => new NRelay1(url),\n *   reqRouter: async (filters) => new Map([\n *     ['wss://relay1.mostr.pub', filters],\n *     ['wss://relay2.mostr.pub', filters],\n *   ]),\n *   eventRouter: async (event) => ['wss://relay1.mostr.pub', 'wss://relay2.mostr.pub'],\n * });\n *\n * // Now you can use the pool like a regular relay.\n * for await (const msg of pool.req([{ kinds: [1] }])) {\n *   if (msg[0] === 'EVENT') console.log(msg[2]);\n *   if (msg[0] === 'EOSE') break;\n * }\n * ```\n *\n * This class is designed with the Outbox model in mind.\n * Instead of passing relay URLs into each method, you pass functions into the contructor that statically-analyze filters and events to determine which relays to use for requesting and publishing events.\n * If a relay wasn't already connected, it will be opened automatically.\n * Defining `open` will also let you use any relay implementation, such as `NRelay1`.\n *\n * Note that `pool.req` may stream duplicate events, while `pool.query` will correctly process replaceable events and deletions within the event set before returning them.\n *\n * `pool.req` will only emit an `EOSE` when all relays in its set have emitted an `EOSE`, and likewise for `CLOSED`.\n */\nexport class NPool<T extends NRelay = NRelay> implements NRelay {\n  private _relays = new Map<string, T>();\n\n  constructor(private opts: NPoolOpts<T>) {}\n\n  /** Get or create a relay instance for the given URL. */\n  public relay(url: string): T {\n    const relay = this._relays.get(url);\n\n    if (relay) {\n      return relay;\n    } else {\n      const relay = this.opts.open(url);\n      this._relays.set(url, relay);\n      return relay;\n    }\n  }\n\n  /** Returns a new pool instance that uses the given relays. Connections are shared with the original pool. */\n  public group(urls: string[]): NPool<T> {\n    return new NPool({\n      open: (url) => this.relay(url),\n      reqRouter: (filters) => new Map(urls.map((url) => [url, filters])),\n      eventRouter: () => urls,\n    });\n  }\n\n  public get relays(): ReadonlyMap<string, T> {\n    return this._relays;\n  }\n\n  /**\n   * Sends a `REQ` to relays based on the configured `reqRouter`.\n   *\n   * `EVENT` messages from the selected relays are yielded.\n   * `EOSE` and `CLOSE` messages are only yielded when all relays have emitted them.\n   *\n   * Deduplication of `EVENT` messages is attempted, so that each event is only yielded once.\n   * A circular set of 1000 is used to track seen event IDs, so it's possible that very\n   * long-running subscriptions (with over 1000 results) may yield duplicate events.\n   */\n  async *req(\n    filters: NostrFilter[],\n    opts?: { signal?: AbortSignal; relays?: string[] },\n  ): AsyncIterable<NostrRelayEVENT | NostrRelayEOSE | NostrRelayCLOSED> {\n    const controller = new AbortController();\n    const signal = opts?.signal ? AbortSignal.any([opts.signal, controller.signal]) : controller.signal;\n\n    const routes = opts?.relays\n      ? new Map(opts.relays.map((url) => [url, filters]))\n      : await this.opts.reqRouter(filters);\n\n    if (routes.size < 1) {\n      return;\n    }\n\n    const machina = new Machina<NostrRelayEVENT | NostrRelayEOSE | NostrRelayCLOSED>(signal);\n\n    const eoses = new Set<string>();\n    const closes = new Set<string>();\n    const events = new CircularSet<string>(1000);\n\n    for (const [url, filters] of routes.entries()) {\n      const relay = this.relay(url);\n      (async () => {\n        for await (const msg of relay.req(filters, { signal })) {\n          if (msg[0] === 'EOSE') {\n            eoses.add(url);\n            if (eoses.size === routes.size) {\n              machina.push(msg);\n            }\n          }\n          if (msg[0] === 'CLOSED') {\n            closes.add(url);\n            if (closes.size === routes.size) {\n              machina.push(msg);\n            }\n          }\n          if (msg[0] === 'EVENT') {\n            const [, , event] = msg;\n            if (!events.has(event.id)) {\n              events.add(event.id);\n              machina.push(msg);\n            }\n          }\n        }\n      })().catch(() => {});\n    }\n\n    try {\n      for await (const msg of machina) {\n        yield msg;\n      }\n    } finally {\n      controller.abort();\n    }\n  }\n\n  /**\n   * Events are sent to relays according to the `eventRouter`.\n   * Returns a fulfilled promise if ANY relay accepted the event,\n   * or a rejected promise if ALL relays rejected or failed to publish the event.\n   */\n  async event(event: NostrEvent, opts?: { signal?: AbortSignal; relays?: string[] }): Promise<void> {\n    const relayUrls = opts?.relays ?? await this.opts.eventRouter(event);\n\n    if (!relayUrls.length) {\n      return;\n    }\n\n    await Promise.any(\n      relayUrls.map((url) => this.relay(url).event(event, opts)),\n    );\n  }\n\n  /**\n   * This method calls `.req` internally and then post-processes the results.\n   * Please read the definition of `.req`.\n   *\n   * - The strategy is to seek regular events quickly, and to wait to find the latest versions of replaceable events.\n   * - Filters for replaceable events will wait for all relays to `EOSE` (or `CLOSE`, or for the signal to be aborted) to ensure the latest event versions are retrieved.\n   * - Filters for regular events will stop as soon as the filters are fulfilled.\n   * - Events are deduplicated, sorted, and only the latest version of replaceable events is kept.\n   * - If the signal is aborted, this method will return partial results instead of throwing.\n   *\n   * To implement a custom strategy, call `.req` directly.\n   */\n  async query(filters: NostrFilter[], opts?: { signal?: AbortSignal; relays?: string[] }): Promise<NostrEvent[]> {\n    const map = new Map<string, NostrEvent>();\n    const events = new NSet(map);\n\n    const limit = filters.reduce((result, filter) => result + getFilterLimit(filter), 0);\n    if (limit === 0) return [];\n\n    try {\n      for await (const msg of this.req(filters, opts)) {\n        if (msg[0] === 'EOSE') break;\n        if (msg[0] === 'EVENT') events.add(msg[2]);\n        if (msg[0] === 'CLOSED') break;\n      }\n    } catch {\n      // Skip errors, return partial results.\n    }\n\n    // Don't sort results of search filters.\n    if (filters.some((filter) => typeof filter.search === 'string')) {\n      return [...map.values()];\n    } else {\n      return [...events];\n    }\n  }\n\n  /** Close all the relays in the pool. */\n  async close(): Promise<void> {\n    await Promise.all(\n      [...this._relays.values()].map((relay) => relay.close()),\n    );\n  }\n\n  async [Symbol.asyncDispose](): Promise<void> {\n    await this.close();\n  }\n}\n", "import { Backoff } from \"./backoff\";\n\n/**\n * ExponentialBackoff increases the backoff-time exponentially.\n * An optional maximum can be provided as an upper bound to the\n * exponent and thus to the returned backoff.\n *\n * The series can be described as ('i' is the current step/retry):\n *    backoff = base * 2^i                | without bound\n *    backoff = base * 2^min(i, expMax)   | with bound\n *\n * Example:\n *\n * 1) Without bound:\n *   base = 1000, expMax = undefined\n *   backoff = 1000 * 2^0 = 1000 // first retry\n *   backoff = 1000 * 2^1 = 2000 // second retry\n *   backoff = 1000 * 2^2 = 4000 // ...doubles with every retry\n *   backoff = 1000 * 2^3 = 8000\n *   backoff = 1000 * 2^4 = 16000\n *   ... // and so on\n *\n * 2) With bound:\n *  base = 1000, expMax = 3\n *  backoff = 1000 * 2^0 = 1000 // first retry\n *  backoff = 1000 * 2^1 = 2000 // second retry\n *  backoff = 1000 * 2^2 = 4000 // third retry\n *  backoff = 1000 * 2^3 = 8000 // maximum reached, don't increase further\n *  backoff = 1000 * 2^3 = 8000\n *  backoff = 1000 * 2^3 = 8000\n *  ... // and so on\n */\nexport class ExponentialBackoff implements Backoff {\n  private readonly base: number;\n  private readonly expMax?: number;\n  private i: number;\n  private _retries: number = 0;\n\n  /**\n   * Creates a new ExponentialBackoff.\n   * @param base the base of the exponentiation\n   * @param expMax the maximum exponent, no bound if undefined\n   */\n  constructor(base: number, expMax?: number) {\n    if (!Number.isInteger(base) || base < 0) {\n      throw new Error(\"Base must be a positive integer or zero\");\n    }\n    if (expMax !== undefined && (!Number.isInteger(expMax) || expMax < 0)) {\n      throw new Error(\"ExpMax must be a undefined, a positive integer or zero\");\n    }\n\n    this.base = base;\n    this.expMax = expMax;\n    this.i = 0;\n  }\n\n  get retries() {\n    return this._retries;\n  }\n\n  get current(): number {\n    return this.base * Math.pow(2, this.i);\n  }\n\n  next(): number {\n    this._retries++;\n    this.i =\n      this.expMax === undefined\n        ? this.i + 1\n        : Math.min(this.i + 1, this.expMax);\n    return this.current;\n  }\n\n  reset(): void {\n    this._retries = 0;\n    this.i = 0;\n  }\n}\n", "import { Queue } from \"./queue\";\n\n/**\n * An array queue is a queue that has an unbounded capacity. Reading from an array queue\n * will return the oldest element and effectively remove it from the queue.\n */\nexport class ArrayQueue<E> implements Queue<E> {\n  private readonly elements: E[];\n\n  constructor() {\n    this.elements = [];\n  }\n\n  add(element: E): void {\n    this.elements.push(element);\n  }\n\n  clear() {\n    this.elements.length = 0;\n  }\n\n  forEach(fn: (element: E) => unknown) {\n    this.elements.forEach(fn);\n  }\n\n  length(): number {\n    return this.elements.length;\n  }\n\n  isEmpty(): boolean {\n    return this.elements.length === 0;\n  }\n\n  peek(): E | undefined {\n    return this.elements[0];\n  }\n\n  read(): E | undefined {\n    return this.elements.shift();\n  }\n}\n", "import { Websocket } from \"./websocket\";\n\n/**\n * Events that can be fired by the websocket.\n */\nexport enum WebsocketEvent {\n  /** Fired when the connection is opened. */\n  open = \"open\",\n\n  /** Fired when the connection is closed. */\n  close = \"close\",\n\n  /** Fired when the connection has been closed because of an error, such as when some data couldn't be sent. */\n  error = \"error\",\n\n  /** Fired when a message is received. */\n  message = \"message\",\n\n  /** Fired when the websocket tries to reconnect after a connection loss. */\n  retry = \"retry\",\n\n  /** Fired when the websocket successfully reconnects after a connection loss. */\n  reconnect = \"reconnect\",\n}\n\n/***\n * Details/properties of a retry-event.\n */\nexport type RetryEventDetail = {\n  /** Number of retries that have been made since the connection was lost. */\n  readonly retries: number;\n\n  /** Time (ms) waited since the last connection-retry. */\n  readonly backoff: number;\n\n  /** Timestamp of when the connection was lost or undefined if the connection has never been established. */\n  readonly lastConnection: Date | undefined;\n};\n\n/**\n * Properties of a reconnect-event.\n */\nexport type ReconnectEventDetail = Omit<RetryEventDetail, \"backoff\">;\n\n/**\n * Maps websocket events to their corresponding event.\n */\nexport type WebsocketEventMap = {\n  [WebsocketEvent.open]: Event;\n  [WebsocketEvent.close]: CloseEvent;\n  [WebsocketEvent.error]: Event;\n  [WebsocketEvent.message]: MessageEvent;\n  [WebsocketEvent.retry]: CustomEvent<RetryEventDetail>;\n  [WebsocketEvent.reconnect]: CustomEvent<ReconnectEventDetail>;\n};\n\n/**\n * Listener for websocket events.\n * */\nexport type WebsocketEventListener<K extends WebsocketEvent> = (\n  instance: Websocket,\n  ev: WebsocketEventMap[K],\n) => unknown;\n\nexport type WebsocketEventListenerParams<K extends WebsocketEvent> = Parameters<\n  WebsocketEventListener<K>\n>;\n\n/**\n * Options for websocket events.\n */\nexport type WebsocketEventListenerOptions = EventListenerOptions &\n  AddEventListenerOptions;\n\n/**\n * Listener for websocket events with options.\n */\nexport type WebsocketEventListenerWithOptions<K extends WebsocketEvent> = {\n  readonly listener: WebsocketEventListener<K>;\n  readonly options?: WebsocketEventListenerOptions;\n};\n\n/**\n * Maps websocket events to their corresponding event-listeners.\n */\nexport type WebsocketEventListeners = {\n  [K in WebsocketEvent]: WebsocketEventListenerWithOptions<K>[];\n};\n", "import { Backoff } from \"./backoff/backoff\";\nimport { WebsocketBuffer } from \"./websocket_buffer\";\nimport {\n  ReconnectEventDetail,\n  RetryEventDetail,\n  WebsocketEvent,\n  WebsocketEventListener,\n  WebsocketEventListenerOptions,\n  WebsocketEventListeners,\n  WebsocketEventListenerWithOptions,\n  WebsocketEventMap,\n} from \"./websocket_event\";\nimport { WebsocketOptions } from \"./websocket_options\";\n\n/**\n * A websocket wrapper that can be configured to reconnect automatically and buffer messages when the websocket is not connected.\n */\nexport class Websocket {\n  private readonly _url: string; // the url to connect to\n  private readonly _protocols?: string | string[]; // the protocols to use\n\n  private _closedByUser: boolean = false; // whether the websocket was closed by the user\n  private _lastConnection?: Date; // timestamp of the last connection\n  private _underlyingWebsocket: WebSocket; // the underlying websocket, e.g. native browser websocket\n  private retryTimeout?: ReturnType<typeof globalThis.setTimeout>; // timeout for the next retry, if any\n\n  private _options: WebsocketOptions &\n    Required<Pick<WebsocketOptions, \"listeners\" | \"retry\">>; // options/config for the websocket\n\n  /**\n   * Creates a new websocket.\n   *\n   * @param url to connect to.\n   * @param protocols optional protocols to use.\n   * @param options optional options to use.\n   */\n  constructor(\n    url: string,\n    protocols?: string | string[],\n    options?: WebsocketOptions,\n  ) {\n    this._url = url;\n    this._protocols = protocols;\n\n    // make a copy of the options to prevent the user from changing them\n    this._options = {\n      buffer: options?.buffer,\n      retry: {\n        maxRetries: options?.retry?.maxRetries,\n        instantReconnect: options?.retry?.instantReconnect,\n        backoff: options?.retry?.backoff,\n      },\n      listeners: {\n        open: [...(options?.listeners?.open ?? [])],\n        close: [...(options?.listeners?.close ?? [])],\n        error: [...(options?.listeners?.error ?? [])],\n        message: [...(options?.listeners?.message ?? [])],\n        retry: [...(options?.listeners?.retry ?? [])],\n        reconnect: [...(options?.listeners?.reconnect ?? [])],\n      },\n    };\n\n    this._underlyingWebsocket = this.tryConnect();\n  }\n\n  /**\n   * Getter for the url.\n   *\n   * @return the url.\n   */\n  get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Getter for the protocols.\n   *\n   * @return the protocols, or undefined if none were provided.\n   */\n  get protocols(): string | string[] | undefined {\n    return this._protocols;\n  }\n\n  /**\n   * Getter for the buffer.\n   *\n   * @return the buffer, or undefined if none was provided.\n   */\n  get buffer(): WebsocketBuffer | undefined {\n    return this._options.buffer;\n  }\n\n  /**\n   * Getter for the maxRetries.\n   *\n   * @return the maxRetries, or undefined if none was provided (no limit).\n   */\n  get maxRetries(): number | undefined {\n    return this._options.retry.maxRetries;\n  }\n\n  /**\n   * Getter for the instantReconnect.\n   *\n   * @return the instantReconnect, or undefined if none was provided.\n   */\n  get instantReconnect(): boolean | undefined {\n    return this._options.retry.instantReconnect;\n  }\n\n  /**\n   * Getter for the backoff.\n   *\n   * @return the backoff, or undefined if none was provided.\n   */\n  get backoff(): Backoff | undefined {\n    return this._options.retry.backoff;\n  }\n\n  /**\n   * Whether the websocket was closed by the user. A websocket is closed by the user by calling close().\n   *\n   * @return true if the websocket was closed by the user, false otherwise.\n   */\n  get closedByUser(): boolean {\n    return this._closedByUser;\n  }\n\n  /**\n   * Getter for the last 'open' event, e.g. the last time the websocket was connected.\n   *\n   * @return the last 'open' event, or undefined if the websocket was never connected.\n   */\n  get lastConnection(): Date | undefined {\n    return this._lastConnection;\n  }\n\n  /**\n   * Getter for the underlying websocket. This can be used to access the browser's native websocket directly.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @return the underlying websocket.\n   */\n  get underlyingWebsocket(): WebSocket {\n    return this._underlyingWebsocket;\n  }\n\n  /**\n   * Getter for the readyState of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n   * @return the readyState of the underlying websocket.\n   */\n  get readyState(): number {\n    return this._underlyingWebsocket.readyState;\n  }\n\n  /**\n   * Getter for the bufferedAmount of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/bufferedAmount\n   * @return the bufferedAmount of the underlying websocket.\n   */\n  get bufferedAmount(): number {\n    return this._underlyingWebsocket.bufferedAmount;\n  }\n\n  /**\n   * Getter for the extensions of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/extensions\n   * @return the extensions of the underlying websocket.\n   */\n  get extensions(): string {\n    return this._underlyingWebsocket.extensions;\n  }\n\n  /**\n   * Getter for the binaryType of the underlying websocket.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/binaryType\n   * @return the binaryType of the underlying websocket.\n   */\n  get binaryType(): BinaryType {\n    return this._underlyingWebsocket.binaryType;\n  }\n\n  /**\n   * Setter for the binaryType of the underlying websocket.\n   *\n   * @param value to set, 'blob' or 'arraybuffer'.\n   */\n  set binaryType(value: BinaryType) {\n    this._underlyingWebsocket.binaryType = value;\n  }\n\n  /**\n   * Sends data over the websocket.\n   *\n   * If the websocket is not connected and a buffer was provided on creation, the data will be added to the buffer.\n   * If no buffer was provided or the websocket was closed by the user, the data will be dropped.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n   * @param data to send.\n   */\n  public send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n    if (this.closedByUser) return; // no-op if closed by user\n\n    if (\n      this._underlyingWebsocket.readyState === this._underlyingWebsocket.OPEN\n    ) {\n      this._underlyingWebsocket.send(data); // websocket is connected, send data\n    } else if (this.buffer !== undefined) {\n      this.buffer.add(data); // websocket is not connected, add data to buffer\n    }\n  }\n\n  /**\n   * Close the websocket. No connection-retry will be attempted after this.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n   * @param code optional close code.\n   * @param reason optional close reason.\n   */\n  public close(code?: number, reason?: string): void {\n    this.cancelScheduledConnectionRetry(); // cancel any scheduled retries\n    this._closedByUser = true; // mark websocket as closed by user\n    this._underlyingWebsocket.close(code, reason); // close underlying websocket with provided code and reason\n  }\n\n  /**\n   * Adds an event listener for the given event-type.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   * @param type of the event to add the listener for.\n   * @param listener to add.\n   * @param options to use when adding the listener.\n   */\n  public addEventListener<K extends WebsocketEvent>(\n    type: K,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): void {\n    this._options.listeners[type].push({ listener, options }); // add listener to list of listeners\n  }\n\n  /**\n   * Removes one or more event listener for the given event-type that match the given listener and options.\n   *\n   * @param type of the event to remove the listener for.\n   * @param listener to remove.\n   * @param options that were used when the listener was added.\n   */\n  public removeEventListener<K extends WebsocketEvent>(\n    type: K,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): void {\n    const isListenerNotToBeRemoved = (\n      l: WebsocketEventListenerWithOptions<K>,\n    ) => l.listener !== listener || l.options !== options;\n\n    (this._options.listeners[type] as WebsocketEventListenerWithOptions<K>[]) =\n      this._options.listeners[type].filter(isListenerNotToBeRemoved); // only keep listeners that are not to be removed\n  }\n\n  /**\n   * Creates a new browser-native websocket and connects it to the given URL with the given protocols\n   * and adds all event listeners to the browser-native websocket.\n   *\n   * @return the created browser-native websocket which is also stored in the '_underlyingWebsocket' property.\n   */\n  private tryConnect(): WebSocket {\n    this._underlyingWebsocket = new WebSocket(this.url, this.protocols); // create new browser-native websocket and add all event listeners\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.open,\n      this.handleOpenEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.close,\n      this.handleCloseEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.error,\n      this.handleErrorEvent,\n    );\n    this._underlyingWebsocket.addEventListener(\n      WebsocketEvent.message,\n      this.handleMessageEvent,\n    );\n\n    return this._underlyingWebsocket;\n  }\n\n  /**\n   * Removes all event listeners from the browser-native websocket and closes it.\n   */\n  private clearWebsocket() {\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.open,\n      this.handleOpenEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.close,\n      this.handleCloseEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.error,\n      this.handleErrorEvent,\n    );\n    this._underlyingWebsocket.removeEventListener(\n      WebsocketEvent.message,\n      this.handleMessageEvent,\n    );\n    this._underlyingWebsocket.close();\n  }\n\n  /**\n   * Handles the 'open' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleOpenEvent = (event: Event) =>\n    this.handleEvent(WebsocketEvent.open, event);\n\n  /**\n   * Handles the 'error' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleErrorEvent = (event: Event) =>\n    this.handleEvent(WebsocketEvent.error, event);\n\n  /**\n   * Handles the 'close' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleCloseEvent = (event: CloseEvent) =>\n    this.handleEvent(WebsocketEvent.close, event);\n\n  /**\n   * Handles the 'message' event of the browser-native websocket.\n   * @param event to handle.\n   */\n  private handleMessageEvent = (event: MessageEvent) =>\n    this.handleEvent(WebsocketEvent.message, event);\n\n  /**\n   * Dispatch an event to all listeners of the given event-type.\n   *\n   * @param type of the event to dispatch.\n   * @param event to dispatch.\n   */\n  private dispatchEvent<K extends WebsocketEvent>(\n    type: K,\n    event: WebsocketEventMap[K],\n  ) {\n    const eventListeners: WebsocketEventListeners[K] =\n      this._options.listeners[type];\n    const newEventListeners: WebsocketEventListeners[K] = [];\n\n    eventListeners.forEach(({ listener, options }) => {\n      listener(this, event); // invoke listener with event\n\n      if (\n        options === undefined ||\n        options.once === undefined ||\n        !options.once\n      ) {\n        newEventListeners.push({ listener, options }); // only keep listener if it isn't a once-listener\n      }\n    });\n\n    this._options.listeners[type] = newEventListeners; // replace old listeners with new listeners that don't include once-listeners\n  }\n\n  /**\n   * Handles the given event by dispatching it to all listeners of the given event-type.\n   *\n   * @param type of the event to handle.\n   * @param event to handle.\n   */\n  private handleEvent<K extends WebsocketEvent>(\n    type: K,\n    event: WebsocketEventMap[K],\n  ) {\n    switch (type) {\n      case WebsocketEvent.close:\n        this.dispatchEvent(type, event);\n        this.scheduleConnectionRetryIfNeeded(); // schedule a new connection retry if the websocket was closed by the server\n        break;\n\n      case WebsocketEvent.open:\n        if (this.backoff !== undefined && this._lastConnection !== undefined) {\n          // websocket was reconnected, dispatch reconnect event and reset backoff\n          const detail: ReconnectEventDetail = {\n            retries: this.backoff.retries,\n            lastConnection: new Date(this._lastConnection),\n          };\n          const event: CustomEvent<ReconnectEventDetail> =\n            new CustomEvent<ReconnectEventDetail>(WebsocketEvent.reconnect, {\n              detail,\n            });\n          this.dispatchEvent(WebsocketEvent.reconnect, event);\n          this.backoff.reset();\n        }\n        this._lastConnection = new Date();\n        this.dispatchEvent(type, event); // dispatch open event and send buffered data\n        this.sendBufferedData();\n        break;\n\n      case WebsocketEvent.retry:\n        this.dispatchEvent(type, event); // dispatch retry event and try to connect\n        this.clearWebsocket(); // clear the old websocket\n        this.tryConnect();\n        break;\n\n      default:\n        this.dispatchEvent(type, event); // dispatch event to all listeners of the given event-type\n        break;\n    }\n  }\n\n  /**\n   * Sends buffered data if there is a buffer defined.\n   */\n  private sendBufferedData() {\n    if (this.buffer === undefined) {\n      return; // no buffer defined, nothing to send\n    }\n\n    for (\n      let ele = this.buffer.read();\n      ele !== undefined;\n      ele = this.buffer.read()\n    ) {\n      this.send(ele); // send buffered data\n    }\n  }\n\n  /**\n   * Schedules a connection-retry if there is a backoff defined and the websocket was not closed by the user.\n   */\n  private scheduleConnectionRetryIfNeeded() {\n    if (this.closedByUser) {\n      return; // user closed the websocket, no retry\n    }\n    if (this.backoff === undefined) {\n      return; // no backoff defined, no retry\n    }\n\n    // handler dispatches the retry event to all listeners of the retry event-type\n    const handleRetryEvent = (detail: RetryEventDetail) => {\n      const event: CustomEvent<RetryEventDetail> = new CustomEvent(\n        WebsocketEvent.retry,\n        { detail },\n      );\n      this.handleEvent(WebsocketEvent.retry, event);\n    };\n\n    // create retry event detail, depending on the 'instantReconnect' option\n    const retryEventDetail: RetryEventDetail = {\n      backoff:\n        this._options.retry.instantReconnect === true ? 0 : this.backoff.next(),\n      retries:\n        this._options.retry.instantReconnect === true\n          ? 0\n          : this.backoff.retries,\n      lastConnection: this._lastConnection,\n    };\n\n    // schedule a new connection-retry if the maximum number of retries is not reached yet\n    if (\n      this._options.retry.maxRetries === undefined ||\n      retryEventDetail.retries <= this._options.retry.maxRetries\n    ) {\n      this.retryTimeout = globalThis.setTimeout(\n        () => handleRetryEvent(retryEventDetail),\n        retryEventDetail.backoff,\n      );\n    }\n  }\n\n  /**\n   * Cancels the scheduled connection-retry, if there is one.\n   */\n  private cancelScheduledConnectionRetry() {\n    globalThis.clearTimeout(this.retryTimeout);\n  }\n}\n", "import { Backoff } from \"./backoff/backoff\";\nimport {\n  WebsocketEvent,\n  WebsocketEventListener,\n  WebsocketEventListenerOptions,\n} from \"./websocket_event\";\nimport { Websocket } from \"./websocket\";\nimport { WebsocketBuffer } from \"./websocket_buffer\";\nimport { WebsocketOptions } from \"./websocket_options\";\n\n/**\n * Builder for websockets.\n */\nexport class WebsocketBuilder {\n  private readonly _url: string;\n\n  private _protocols?: string | string[];\n  private _options?: WebsocketOptions;\n\n  /**\n   * Creates a new WebsocketBuilder.\n   *\n   * @param url the url to connect to\n   */\n  constructor(url: string) {\n    this._url = url;\n  }\n\n  /**\n   * Getter for the url.\n   *\n   * @returns the url\n   */\n  get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Adds protocols to the websocket. Subsequent calls to this method will override the previously set protocols.\n   *\n   * @param protocols the protocols to add\n   */\n  public withProtocols(\n    protocols: string | string[] | undefined,\n  ): WebsocketBuilder {\n    this._protocols = protocols;\n    return this;\n  }\n\n  /**\n   * Getter for the protocols.\n   *\n   * @returns the protocols, undefined if no protocols have been set\n   */\n  get protocols(): string | string[] | undefined {\n    return this._protocols;\n  }\n\n  /**\n   * Sets the maximum number of retries before giving up. No limit if undefined.\n   *\n   * @param maxRetries the maximum number of retries before giving up\n   */\n  public withMaxRetries(maxRetries: number | undefined): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, maxRetries },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for the maximum number of retries before giving up.\n   *\n   * @returns the maximum number of retries before giving up, undefined if no maximum has been set\n   */\n  get maxRetries(): number | undefined {\n    return this._options?.retry?.maxRetries;\n  }\n\n  /**\n   * Sets wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.\n   *\n   * @param instantReconnect wether to reconnect immediately after a connection has been lost\n   */\n  public withInstantReconnect(\n    instantReconnect: boolean | undefined,\n  ): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, instantReconnect },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.\n   *\n   * @returns wether to reconnect immediately after a connection has been lost, undefined if no value has been set\n   */\n  get instantReconnect(): boolean | undefined {\n    return this._options?.retry?.instantReconnect;\n  }\n\n  /**\n   * Adds a backoff to the websocket. Subsequent calls to this method will override the previously set backoff.\n   *\n   * @param backoff the backoff to add\n   */\n  public withBackoff(backoff: Backoff | undefined): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      retry: { ...this._options?.retry, backoff },\n    };\n    return this;\n  }\n\n  /**\n   * Getter for the backoff.\n   *\n   * @returns the backoff, undefined if no backoff has been set\n   */\n  get backoff(): Backoff | undefined {\n    return this._options?.retry?.backoff;\n  }\n\n  /**\n   * Adds a buffer to the websocket. Subsequent calls to this method will override the previously set buffer.\n   *\n   * @param buffer the buffer to add\n   */\n  public withBuffer(buffer: WebsocketBuffer | undefined): WebsocketBuilder {\n    this._options = { ...this._options, buffer };\n    return this;\n  }\n\n  /**\n   * Getter for the buffer.\n   *\n   * @returns the buffer, undefined if no buffer has been set\n   */\n  get buffer(): WebsocketBuffer | undefined {\n    return this._options?.buffer;\n  }\n\n  /**\n   * Adds an 'open' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onOpen(\n    listener: WebsocketEventListener<WebsocketEvent.open>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.open, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'close' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onClose(\n    listener: WebsocketEventListener<WebsocketEvent.close>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.close, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'error' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onError(\n    listener: WebsocketEventListener<WebsocketEvent.error>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.error, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'message' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onMessage(\n    listener: WebsocketEventListener<WebsocketEvent.message>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.message, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'retry' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onRetry(\n    listener: WebsocketEventListener<WebsocketEvent.retry>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.retry, listener, options);\n    return this;\n  }\n\n  /**\n   * Adds an 'reconnect' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be\n   * called in the order they were added.\n   *\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  public onReconnect(\n    listener: WebsocketEventListener<WebsocketEvent.reconnect>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this.addListener(WebsocketEvent.reconnect, listener, options);\n    return this;\n  }\n\n  /**\n   * Builds the websocket.\n   *\n   * @return a new websocket, with the set options\n   */\n  public build(): Websocket {\n    return new Websocket(this._url, this._protocols, this._options); // instantiate the websocket with the set options\n  }\n\n  /**\n   * Adds an event listener to the options.\n   *\n   * @param event the event to add the listener to\n   * @param listener the listener to add\n   * @param options the listener options\n   */\n  private addListener<K extends WebsocketEvent>(\n    event: WebsocketEvent,\n    listener: WebsocketEventListener<K>,\n    options?: WebsocketEventListenerOptions,\n  ): WebsocketBuilder {\n    this._options = {\n      ...this._options,\n      listeners: {\n        open: this._options?.listeners?.open ?? [],\n        close: this._options?.listeners?.close ?? [],\n        error: this._options?.listeners?.error ?? [],\n        message: this._options?.listeners?.message ?? [],\n        retry: this._options?.listeners?.retry ?? [],\n        reconnect: this._options?.listeners?.reconnect ?? [],\n        [event]: [\n          ...(this._options?.listeners?.[event] ?? []),\n          { listener, options },\n        ],\n      },\n    };\n    return this;\n  }\n}\n", "import {\n  NostrClientMsg,\n  NostrClientREQ,\n  NostrEvent,\n  NostrFilter,\n  NostrRelayCLOSED,\n  NostrRelayCOUNT,\n  NostrRelayEOSE,\n  NostrRelayEVENT,\n  NostrRelayMsg,\n  NostrRelayNOTICE,\n  NostrRelayOK,\n  NRelay,\n} from '@jsr/nostrify__types';\nimport { getFilterLimit, matchFilters, verifyEvent as _verifyEvent } from 'nostr-tools';\nimport { ArrayQueue, Backoff, ExponentialBackoff, Websocket, WebsocketBuilder, WebsocketEvent } from 'websocket-ts';\n\nimport { Machina } from './utils/Machina.js';\nimport { NSchema as n } from './NSchema.js';\nimport { NSet } from './NSet.js';\n\n/** Map of EventEmitter events. */\ntype EventMap = {\n  [k: `ok:${string}`]: NostrRelayOK;\n  [k: `sub:${string}`]: NostrRelayEVENT | NostrRelayEOSE | NostrRelayCLOSED;\n  [k: `count:${string}`]: NostrRelayCOUNT | NostrRelayCLOSED;\n  notice: NostrRelayNOTICE;\n};\n\n/** Options used for constructing an `NRelay1` instance. */\nexport interface NRelay1Opts {\n  /** Respond to `AUTH` challenges by producing a signed kind `22242` event. */\n  auth?(challenge: string): Promise<NostrEvent>;\n  /** Configure reconnection strategy, or set to `false` to disable. Default: `new ExponentialBackoff(1000)`. */\n  backoff?: Backoff | false;\n  /** How long to wait (in milliseconds) for the caller to create a subscription before closing the connection. Set to `false` to disable. Default: `30_000`. */\n  idleTimeout?: number | false;\n  /** Ensure the event is valid before returning it. Default: `nostrTools.verifyEvent`. */\n  verifyEvent?(event: NostrEvent): boolean;\n  /** Logger callback. */\n  log?(log: NRelay1Log): void;\n}\n\nexport interface NRelay1Log {\n  level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal' | 'critical';\n  ns: string;\n  [k: string]: JsonValue | undefined | { toJSON(): JsonValue } | Error;\n}\n\n/** Single relay connection over WebSocket. */\nexport class NRelay1 implements NRelay {\n  socket: Websocket;\n\n  private subs = new Map<string, NostrClientREQ>();\n  private closedByUser = false;\n  private idleTimer?: number;\n  private controller = new AbortController();\n\n  private ee = new EventTarget();\n\n  get subscriptions(): readonly NostrClientREQ[] {\n    return [...this.subs.values()];\n  }\n\n  private log(log: NRelay1Log): void {\n    this.opts.log?.({ ...log, url: this.url });\n  }\n\n  constructor(private url: string, private opts: NRelay1Opts = {}) {\n    this.socket = this.createSocket();\n    this.maybeStartIdleTimer();\n  }\n\n  /** Create (and open) a WebSocket connection with automatic reconnect. */\n  private createSocket(): Websocket {\n    const { backoff = new ExponentialBackoff(1000) } = this.opts;\n\n    return new WebsocketBuilder(this.url)\n      .withBuffer(new ArrayQueue())\n      .withBackoff(backoff === false ? undefined : backoff)\n      .onOpen((socket) => {\n        this.log({\n          level: 'debug',\n          ns: 'relay.ws.state',\n          state: 'open',\n          readyState: socket.readyState,\n        });\n        for (const req of this.subs.values()) {\n          this.send(req);\n        }\n      })\n      .onClose((socket) => {\n        this.log({\n          level: 'debug',\n          ns: 'relay.ws.state',\n          state: 'close',\n          readyState: socket.readyState,\n        });\n        // If the connection closes on its own and there are no active subscriptions, let it stay closed.\n        if (!this.subs.size) {\n          this.socket.close();\n        }\n      })\n      .onReconnect((socket) => {\n        this.log({\n          level: 'debug',\n          ns: 'relay.ws.state',\n          state: 'reconnect',\n          readyState: socket.readyState,\n        });\n      })\n      .onRetry((socket, e) => {\n        this.log({\n          level: 'warn',\n          ns: 'relay.ws.retry',\n          readyState: socket.readyState,\n          backoff: e.detail.backoff,\n        });\n      })\n      .onError((socket) => {\n        this.log({ level: 'error', ns: 'relay.ws.error', readyState: socket.readyState });\n      })\n      .onMessage((_socket, e) => {\n        if (typeof e.data !== 'string') {\n          this.close();\n          return;\n        }\n\n        const result = n.json().pipe(n.relayMsg()).safeParse(e.data);\n\n        if (result.success) {\n          this.log({ level: 'trace', ns: 'relay.ws.message', data: result.data as JsonValue });\n          this.receive(result.data);\n        } else {\n          this.log({ level: 'warn', ns: 'relay.ws.message', error: result.error });\n        }\n      })\n      .build();\n  }\n\n  /** Handle a NIP-01 relay message. */\n  protected receive(msg: NostrRelayMsg): void {\n    const { auth, verifyEvent = _verifyEvent } = this.opts;\n\n    switch (msg[0]) {\n      case 'EVENT':\n        if (!verifyEvent(msg[2])) break;\n        this.ee.dispatchEvent(new CustomEvent(`sub:${msg[1]}`, { detail: msg }));\n        break;\n      case 'EOSE':\n        this.ee.dispatchEvent(new CustomEvent(`sub:${msg[1]}`, { detail: msg }));\n        break;\n      case 'CLOSED':\n        this.subs.delete(msg[1]);\n        this.maybeStartIdleTimer();\n        this.ee.dispatchEvent(new CustomEvent(`sub:${msg[1]}`, { detail: msg }));\n        this.ee.dispatchEvent(new CustomEvent(`count:${msg[1]}`, { detail: msg }));\n        break;\n      case 'OK':\n        this.ee.dispatchEvent(new CustomEvent(`ok:${msg[1]}`, { detail: msg }));\n        break;\n      case 'NOTICE':\n        this.ee.dispatchEvent(new CustomEvent('notice', { detail: msg }));\n        break;\n      case 'COUNT':\n        this.ee.dispatchEvent(new CustomEvent(`count:${msg[1]}`, { detail: msg }));\n        break;\n      case 'AUTH':\n        auth?.(msg[1]).then((event) => this.send(['AUTH', event])).catch(() => {});\n    }\n  }\n\n  /** Send a NIP-01 client message to the relay. */\n  protected send(msg: NostrClientMsg): void {\n    this.log({ level: 'trace', ns: 'relay.ws.send', data: msg as JsonValue });\n    this.wake();\n\n    switch (msg[0]) {\n      case 'REQ':\n        this.subs.set(msg[1], msg);\n        break;\n      case 'CLOSE':\n        this.subs.delete(msg[1]);\n        this.maybeStartIdleTimer();\n        break;\n      case 'EVENT':\n      case 'COUNT':\n        return this.socket.send(JSON.stringify(msg));\n    }\n\n    if (this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(msg));\n    }\n  }\n\n  async *req(\n    filters: NostrFilter[],\n    opts: { signal?: AbortSignal } = {},\n  ): AsyncGenerator<NostrRelayEVENT | NostrRelayEOSE | NostrRelayCLOSED> {\n    const { signal } = opts;\n    const subscriptionId = crypto.randomUUID();\n\n    const msgs = this.on(`sub:${subscriptionId}`, signal);\n    const req: NostrClientREQ = ['REQ', subscriptionId, ...filters];\n\n    this.send(req);\n\n    try {\n      for await (const msg of msgs) {\n        if (msg[0] === 'EOSE') yield msg;\n        if (msg[0] === 'CLOSED') break;\n        if (msg[0] === 'EVENT') {\n          if (matchFilters(filters, msg[2])) {\n            yield msg;\n          } else {\n            continue;\n          }\n        }\n      }\n    } finally {\n      this.send(['CLOSE', subscriptionId]);\n    }\n  }\n\n  async query(filters: NostrFilter[], opts?: { signal?: AbortSignal }): Promise<NostrEvent[]> {\n    const events = new NSet();\n\n    const limit = filters.reduce((result, filter) => result + getFilterLimit(filter), 0);\n    if (limit === 0) return [];\n\n    for await (const msg of this.req(filters, opts)) {\n      if (msg[0] === 'EOSE') break;\n      if (msg[0] === 'EVENT') events.add(msg[2]);\n      if (msg[0] === 'CLOSED') throw new Error('Subscription closed');\n\n      if (events.size >= limit) {\n        break;\n      }\n    }\n\n    return [...events];\n  }\n\n  async event(event: NostrEvent, opts?: { signal?: AbortSignal }): Promise<void> {\n    const result = this.once(`ok:${event.id}`, opts?.signal);\n\n    try {\n      this.send(['EVENT', event]);\n    } catch (e) {\n      result.catch(() => {});\n      throw e;\n    }\n\n    const [, , ok, reason] = await result;\n\n    if (!ok) {\n      throw new Error(reason);\n    }\n  }\n\n  async count(\n    filters: NostrFilter[],\n    opts?: { signal?: AbortSignal },\n  ): Promise<{ count: number; approximate?: boolean }> {\n    const subscriptionId = crypto.randomUUID();\n    const result = this.once(`count:${subscriptionId}`, opts?.signal);\n\n    try {\n      this.send(['COUNT', subscriptionId, ...filters]);\n    } catch (e) {\n      result.catch(() => {});\n      throw e;\n    }\n\n    const msg = await result;\n\n    switch (msg[0]) {\n      case 'CLOSED':\n        throw new Error('Subscription closed');\n      case 'COUNT': {\n        const [, , count] = msg;\n        return count;\n      }\n    }\n  }\n\n  /** Get a stream of EE events. */\n  private async *on<K extends keyof EventMap>(key: K, signal?: AbortSignal): AsyncIterable<EventMap[K]> {\n    const _signal = signal ? AbortSignal.any([this.controller.signal, signal]) : this.controller.signal;\n\n    if (_signal.aborted) throw this.abortError();\n\n    const machina = new Machina<EventMap[K]>(_signal);\n    const onMsg = (e: Event) => machina.push((e as CustomEvent<EventMap[K]>).detail);\n\n    this.ee.addEventListener(key, onMsg);\n\n    try {\n      for await (const msg of machina) {\n        yield msg;\n      }\n    } finally {\n      this.ee.removeEventListener(key, onMsg);\n    }\n  }\n\n  /** Wait for a single EE event. */\n  private async once<K extends keyof EventMap>(key: K, signal?: AbortSignal): Promise<EventMap[K]> {\n    for await (const msg of this.on(key, signal)) {\n      return msg;\n    }\n    throw new Error('Unreachable');\n  }\n\n  protected abortError(): DOMException {\n    return new DOMException('The signal has been aborted', 'AbortError');\n  }\n\n  /** Start the idle time if applicable. */\n  private maybeStartIdleTimer(): void {\n    const { idleTimeout = 30_000 } = this.opts;\n\n    // If the idle timeout is disabled, do nothing.\n    if (idleTimeout === false) return;\n    // If a timer is already running, let it continue without disruption.\n    if (this.idleTimer) return;\n    // If there are still subscriptions, the connection is not \"idle\".\n    if (this.subs.size) return;\n    // If the connection was manually closed, there's no need to start a timer.\n    if (this.closedByUser) return;\n\n    this.log({ level: 'debug', ns: 'relay.idletimer', state: 'running', timeout: idleTimeout });\n    this.idleTimer = setTimeout(() => {\n      this.log({ level: 'debug', ns: 'relay.idletimer', state: 'aborted', timeout: idleTimeout });\n      this.socket.close();\n    }, idleTimeout);\n  }\n\n  /** Stop the idle timer. */\n  private stopIdleTimer(): void {\n    this.log({ level: 'debug', ns: 'relay.idletimer', state: 'stopped' });\n    clearTimeout(this.idleTimer);\n    this.idleTimer = undefined;\n  }\n\n  /** Make a new WebSocket, but only if it was closed by an idle timeout. */\n  private wake(): void {\n    this.stopIdleTimer();\n\n    if (!this.closedByUser && this.socket.closedByUser) {\n      this.log({ level: 'debug', ns: 'relay.wake', state: 'awoken' });\n      this.socket = this.createSocket();\n    } else if (this.closedByUser || this.socket.closedByUser) {\n      this.log({ level: 'debug', ns: 'relay.wake', state: 'closed' });\n    } else {\n      this.log({ level: 'debug', ns: 'relay.wake', state: 'awake' });\n    }\n  }\n\n  /**\n   * Close the relay connection and prevent it from reconnecting.\n   * After this you should dispose of the `NRelay1` instance and create a new one to connect again.\n   */\n  async close(): Promise<void> {\n    this.closedByUser = true;\n    this.socket.close();\n    this.stopIdleTimer();\n    this.controller.abort();\n\n    if (this.socket.readyState !== WebSocket.CLOSED) {\n      await new Promise((resolve) => {\n        this.socket.addEventListener(WebsocketEvent.close, resolve, { once: true });\n      });\n    }\n  }\n\n  async [Symbol.asyncDispose](): Promise<void> {\n    await this.close();\n  }\n}\n\n/** Native JSON primitive value, including objects and arrays. */\ntype JsonValue =\n  | { [key: string]: JsonValue | undefined }\n  | JsonValue[]\n  | string\n  | number\n  | boolean\n  | null;\n", "// deno-lint-ignore-file require-await\n\nimport { finalizeEvent, getPublicKey, nip04, nip44 } from 'nostr-tools';\n\nimport { NostrEvent } from '@jsr/nostrify__types';\nimport { NostrSigner } from '@jsr/nostrify__types';\n\n/**\n * NIP-07-compatible signer with secret key. It is a drop-in replacement for `window.nostr`.\n *\n * Usage:\n *\n * ```ts\n * const signer = new NSecSigner(secretKey);\n * const pubkey = await signer.getPublicKey();\n * const event = await signer.signEvent({ kind: 1, content: 'Hello, world!', tags: [], created_at: 0 });\n * ```\n */\nexport class NSecSigner implements NostrSigner {\n  #secretKey: Uint8Array;\n  private pubkey?: string;\n\n  constructor(secretKey: Uint8Array) {\n    this.#secretKey = secretKey;\n  }\n\n  async getPublicKey(): Promise<string> {\n    return this.pubkey ??= getPublicKey(this.#secretKey);\n  }\n\n  async signEvent(event: Omit<NostrEvent, 'id' | 'pubkey' | 'sig'>): Promise<NostrEvent> {\n    return finalizeEvent(event, this.#secretKey);\n  }\n\n  readonly nip04 = {\n    encrypt: async (pubkey: string, plaintext: string): Promise<string> => {\n      return nip04.encrypt(this.#secretKey, pubkey, plaintext);\n    },\n\n    decrypt: async (pubkey: string, ciphertext: string): Promise<string> => {\n      return nip04.decrypt(this.#secretKey, pubkey, ciphertext);\n    },\n  };\n\n  #getConversationKey(pubkey: string): Uint8Array {\n    return nip44.v2.utils.getConversationKey(this.#secretKey, pubkey);\n  }\n\n  readonly nip44 = {\n    encrypt: async (pubkey: string, plaintext: string): Promise<string> => {\n      const conversationKey = this.#getConversationKey(pubkey);\n      return nip44.v2.encrypt(plaintext, conversationKey);\n    },\n\n    decrypt: async (pubkey: string, ciphertext: string): Promise<string> => {\n      const conversationKey = this.#getConversationKey(pubkey);\n      return nip44.v2.decrypt(ciphertext, conversationKey);\n    },\n  };\n}\n", "import { BunkerURI, NConnectSigner, type NostrSigner, type NPool, NSecSigner } from '@jsr/nostrify__nostrify';\nimport { generateSecretKey, getPublicKey, nip19 } from 'nostr-tools';\n\n/** An object represeting any supported Nostr login credentials. */\nexport type NLoginType = NLoginNsec | NLoginBunker | NLoginExtension | NLoginOther;\n\n/** Nostr login with nsec. */\nexport type NLoginNsec = NLoginBase<'nsec', {\n  nsec: `nsec1${string}`;\n}>;\n\n/** NIP-46 (aka remote signer) login. */\nexport type NLoginBunker = NLoginBase<'bunker', {\n  bunkerPubkey: string;\n  clientNsec: `nsec1${string}`;\n  relays: string[];\n}>;\n\n/** NIP-07 (browser extension) login. */\nexport type NLoginExtension = NLoginBase<'extension', null>;\n\n/** Additional login types created by the library user. */\nexport type NLoginOther = NLoginBase<`x-${string}`, {\n  [key: string]: unknown;\n}>;\n\n/** Base properties shared by Nostr login objects. */\ninterface NLoginBase<T extends string, D> {\n  id: string;\n  type: T;\n  pubkey: string;\n  createdAt: string;\n  data: D;\n}\n\n/** Class representing Nostr login credentials. */\nexport class NLogin<T extends string, D> implements NLoginBase<T, D> {\n  public id: string;\n  public type: T;\n  public pubkey: string;\n  public createdAt: string;\n  public data: D;\n\n  constructor(type: T, pubkey: string, data: D) {\n    this.id = `${type}:${pubkey}`;\n    this.type = type;\n    this.pubkey = pubkey;\n    this.createdAt = new Date().toISOString();\n    this.data = data;\n  }\n\n  /** Create a login object from an nsec. */\n  static fromNsec(nsec: string): NLoginNsec {\n    const decoded = nip19.decode(nsec);\n\n    if (decoded.type !== 'nsec') {\n      throw new Error('Invalid nsec');\n    }\n\n    const sk = decoded.data;\n    const pubkey = getPublicKey(sk);\n\n    return new NLogin('nsec', pubkey, {\n      nsec: nip19.nsecEncode(sk),\n    });\n  }\n\n  /** Create a login object from a bunker URI. */\n  static async fromBunker(uri: string, pool: NPool): Promise<NLoginBunker> {\n    const { pubkey: bunkerPubkey, secret, relays } = new BunkerURI(uri);\n\n    if (!relays.length) {\n      throw new Error('No relay provided');\n    }\n\n    const sk = generateSecretKey();\n    const nsec = nip19.nsecEncode(sk);\n    const clientSigner = new NSecSigner(sk);\n\n    const signer = new NConnectSigner({\n      relay: pool.group(relays),\n      pubkey: bunkerPubkey,\n      signer: clientSigner,\n      timeout: 60_000,\n    });\n\n    await signer.connect(secret);\n    const pubkey = await signer.getPublicKey();\n\n    return new NLogin('bunker', pubkey, {\n      bunkerPubkey,\n      clientNsec: nsec,\n      relays,\n    });\n  }\n\n  /** Create a login object from a browser extension. */\n  static async fromExtension(): Promise<NLoginExtension> {\n    const windowSigner = (globalThis as unknown as { nostr?: NostrSigner }).nostr;\n\n    if (!windowSigner) {\n      throw new Error('Nostr extension is not available');\n    }\n\n    const pubkey = await windowSigner.getPublicKey();\n\n    return new NLogin('extension', pubkey, null);\n  }\n\n  /** Convert to a JSON-serializable object. */\n  toJSON(): NLoginBase<T, D> {\n    return {\n      id: this.id,\n      type: this.type,\n      pubkey: this.pubkey,\n      createdAt: this.createdAt,\n      data: this.data,\n    };\n  }\n}\n", "import { jsx } from 'react/jsx-runtime';\n\nimport { NostrLoginContext, NostrLoginContextType } from './NostrLoginContext.js';\nimport { useNostrLoginReducer } from './useNostrLoginReducer.js';\n\nimport type { FC, ReactNode } from 'npm:react@^18.0.0';\n\n/** Props for `NostrLoginProvider`. */\ninterface NostrLoginProviderProps {\n  /** The child components that will have access to the context. */\n  children: ReactNode;\n  /** The key used to store (and revive) the logins in localStorage. */\n  storageKey: string;\n}\n\n/**\n * NostrLoginProvider is a React component that provides a context for managing Nostr logins.\n * It uses a reducer to handle the state of logins and stores them in localStorage.\n */\nexport const NostrLoginProvider: FC<NostrLoginProviderProps> = ({ children, storageKey }: NostrLoginProviderProps) => {\n  const [logins, dispatch] = useNostrLoginReducer(storageKey);\n\n  const value: NostrLoginContextType = {\n    logins,\n    addLogin: (login) => dispatch({ type: 'login.add', login }),\n    removeLogin: (id) => dispatch({ type: 'login.remove', id }),\n    setLogin: (id) => dispatch({ type: 'login.set', id }),\n    clearLogins: () => dispatch({ type: 'login.clear' }),\n  };\n\n  return jsx(NostrLoginContext.Provider, { value, children });\n};\n", "import { type Context, createContext } from 'react';\n\nimport type { NLoginType } from './NLogin.ts';\n\n/**\n * NostrLoginContextType defines the shape of the context that will be provided\n * to components that need access to the Nostr login state.\n */\nexport type NostrLoginContextType = {\n  /** The list of Nostr logins. */\n  logins: readonly NLoginType[];\n  /** Dispatch an action to add a login to the state. */\n  addLogin: (login: NLoginType) => void;\n  /** Dispatch an action to remove a login from the state. */\n  removeLogin: (loginId: string) => void;\n  /** Dispatch an action to set the user's current login (by moving it to the top of the state). */\n  setLogin: (loginId: string) => void;\n  /** Dispatch an action to clear the login state. */\n  clearLogins: () => void;\n};\n\n/**\n * NostrLoginContext is a React context that provides access to the Nostr login state and\n * a dispatch function to update the state.\n */\nexport const NostrLoginContext: Context<NostrLoginContextType | undefined> = createContext<\n  NostrLoginContextType | undefined\n>(undefined);\n", "import { useEffect, useReducer } from 'react';\n\nimport { type NLoginAction, nostrLoginReducer } from './nostrLoginReducer.js';\n\nimport type { NLoginType } from './NLogin.ts';\n\nexport function useNostrLoginReducer(\n  storageKey: string,\n): [state: NLoginType[], dispatch: (action: NLoginAction) => void] {\n  const [state, dispatch] = useReducer(nostrLoginReducer, [], () => {\n    const stored = localStorage.getItem(storageKey);\n    return stored ? JSON.parse(stored) : [];\n  });\n\n  useEffect(() => {\n    localStorage.setItem(storageKey, JSON.stringify(state));\n  }, [state]);\n\n  return [state, dispatch];\n}\n", "import type { NLoginType } from './NLogin.ts';\n\nexport type NLoginAction =\n  | { type: 'login.add'; login: NLoginType; set?: boolean }\n  | { type: 'login.remove'; id: string }\n  | { type: 'login.set'; id: string }\n  | { type: 'login.clear' };\n\nexport function nostrLoginReducer(state: NLoginType[], action: NLoginAction): NLoginType[] {\n  switch (action.type) {\n    case 'login.add': {\n      const filtered = state.filter((login) => login.id !== action.login.id);\n      return action.set ? [action.login, ...filtered] : [...filtered, action.login];\n    }\n\n    case 'login.remove': {\n      return state.filter((login) => login.id !== action.id);\n    }\n\n    case 'login.set': {\n      const login = state.find((login) => login.id === action.id);\n\n      if (!login) {\n        return state;\n      }\n\n      const filtered = state.filter((login) => login.id !== action.id);\n      return [login, ...filtered];\n    }\n\n    case 'login.clear': {\n      return [];\n    }\n\n    default: {\n      return state;\n    }\n  }\n}\n", "import { NBrowserSigner, NConnectSigner, type NostrSigner, type NPool, NSecSigner } from '@jsr/nostrify__nostrify';\nimport { nip19 } from 'nostr-tools';\n\nimport type { NLoginBunker, NLoginExtension, NLoginNsec } from './NLogin.ts';\n\n/** Represents a Nostr user with authentication credentials. */\nexport class NUser {\n  constructor(\n    /** The authentication method used for this user */\n    readonly method: 'nsec' | 'bunker' | 'extension' | `x-${string}`,\n    /** The public key of the user in hex format. */\n    readonly pubkey: string,\n    /** The signer that can sign events on behalf of this user. */\n    readonly signer: NostrSigner,\n  ) {}\n\n  static fromNsecLogin(login: NLoginNsec): NUser {\n    const sk = nip19.decode(login.data.nsec) as { type: 'nsec'; data: Uint8Array };\n\n    return new NUser(\n      login.type,\n      login.pubkey,\n      new NSecSigner(sk.data),\n    );\n  }\n\n  static fromBunkerLogin(login: NLoginBunker, pool: NPool): NUser {\n    const clientSk = nip19.decode(login.data.clientNsec) as { type: 'nsec'; data: Uint8Array };\n    const clientSigner = new NSecSigner(clientSk.data);\n\n    return new NUser(\n      login.type,\n      login.pubkey,\n      new NConnectSigner({\n        relay: pool.group(login.data.relays),\n        pubkey: login.pubkey,\n        signer: clientSigner,\n        timeout: 60_000,\n      }),\n    );\n  }\n\n  static fromExtensionLogin(login: NLoginExtension): NUser {\n    return new NUser(\n      login.type,\n      login.pubkey,\n      new NBrowserSigner(),\n    );\n  }\n}\n", "import { useContext } from 'react';\n\nimport { NostrLoginContext, type NostrLoginContextType } from './NostrLoginContext.js';\n\nexport function useNostrLogin(): NostrLoginContextType {\n  const context = useContext(NostrLoginContext);\n\n  if (!context) {\n    throw new Error('useNostrLogin must be used within a NostrLoginProvider');\n  }\n\n  return context;\n}\n"],
  "mappings": "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",
  "names": ["_a", "_b", "v", "bf", "_a", "_b", "_a", "_b", "_computedKey", "util", "objectUtil", "errorUtil", "errorMap", "_a", "_b", "ctx", "result", "issues", "elements", "processed", "result", "r", "ZodFirstPartyTypeKind", "event", "_computedKey", "_computedKey", "_resolve", "_a", "relay", "filters", "_computedKey", "WebsocketEvent", "_a", "_b", "event", "_a", "_b", "_b", "_a", "verifyEvent", "_computedKey", "import_react", "login", "import_react"]
}
